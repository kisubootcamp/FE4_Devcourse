# Typescript type system

### 1. string

```ts
let multiLine: string = `This is
    a multiline string`;
```

> ` ` 템플릿 리터럴을 사용하여 여러 줄 문자열 또한 스트링 타입 지정 가능

### 2. number

```ts
let age: number = 10; // 10진수
let hex: number = 0xff; // 16진수
let binary: number = 0b1010; // 2진수
let float: number = 3.14; // 실수
```

> number 타입으로 10진수, 16진수, 2진수, 실수 타입 지정 가능

### 3. boolean(논리형)

> remind

- truthy, falsy
- falsy -> 0, -0, "", null, undefined, NaN
- truthy? -> falsy를 제외한 모든 값

### 4. null, undefined

```ts
let nul = null;
let unde = undefined;
```

> null과 undefined를 할당하게 되면 타입 추론으로 null과 undefiend가 될것 같지만 any 타입으로 추론됨; 언젠간 할당이 될것이라고 생각하기 때문

### 5. any

any 타입은 아무거나 허용하겠다는 것 이는 타입을 검사하지 않겠다는 뜻
-> ts를 사용 할 이유가 없다
그렇기 때문에 남용을 피해야 함. 디버깅 또는 타입을 모르는 상황일 때 잠시 쓰고 후에 꼭 바꾸어줘야함

### 6. unknown

unknown 타입은 any의 순한만, 안전한 any라고 할 수 있다.
any와 같이 타입 검사를 하지 않지만, 값을 사용하려고 할 때 타입 검증을 꼭 해야함.

```ts
let input: unknown = "Hello";
input = 3.14;

if (typeof input === "number") {
  console.log(input.toFixed(0));
}
```

### 7. 배열 (array)

```ts
let arr: [] = []; // 빈 배열 생성

let numArr: number[] = [10, 20];
let numArr2: Array<number> = [10, 20]; // 예전에 이렇게 썼음

let strArr: string[] = ["A", "B", "C"];
let strArr2: Array<string> = ["A", "B", "C"];

let boolArr: boolean[] = [true, false];
let boolArr2: Array<boolean> = [true, false];

let undefinedArr: undefined[] = [undefined, undefined];
let undefinedArr2: Array<undefined> = [undefined, undefined];

let nullArr: null[] = [null, null];
let nullArr2: Array<null> = [null, null];

let objArr: {}[] = [{}, {}];

let matrix: number[][] = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
];

let matrix2: Array<Array<number>> = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
];

let cube: number[][][] = [
  [
    [1, 2],
    [3, 4],
  ],
  [
    [5, 6],
    [7, 8],
  ],
];
```

### 8. 튜플 (tuple)

> 특정 형태를 갖는 배열을 의미, 고정된 인덱스의 고정된 타입만 올 수 있음

```ts
let mixArr: [number, string] = [10, "A"];
let mixArr2: [number, number[]] = [10, [20, 30]];
let mixArr3: [number, [], {}] = [10, [], {}];

let mixTuple: [number, string, object][] = [
  [1, "hello", { key: "value" }],
  [2, "world", { key: "example" }],
];
```

`고정된 인덱스의 고정된 타입만 올 수 있기 때문에 주의 해야함`

### 9. bigint

- bigint는 데이터 타입일 뿐 꼭 큰 숫자만 올 수 있는 것이 아님
- bigint는 bigint 끼리만 계산 가능

```ts
console.log(Number.MAX_SAFE_INTEGER);
const bigNumber: bigint = 9007199254740997n;
console.log(bigNumber);
```

## 타입 추론

> 타입스크립트가 타입을 `자동`으로 `추론` 해주는 기능
> `명시적으로 타입을 쓰지 않아도 코드 내용을 보고 타입스크립트가 스스로 타입을 추축`

### 10. 객체 (object)

객체를 타입을 표현하는 방법은 세가지가 있음

```ts
let obj: object = {}; // 래퍼 객체를 제외한 모든 객체가 들어갈 수 있음, 즉 원시타입은 불가
let obj: {} = {}; // null과 undefined를 제외한 모든 값을 허용
let obj: Record<string, never> = {}; // 유틸리티 타입으로 객체의 키 값은 문자열이며 값은 절대 올 수 없음, 즉 이건 빈 객체를 생성할 때 사용하는 방법
```

### 11. readonly

```ts
let obj: {
  readonly name: string;
  age: 20;
  gender?: string; // 옵셔널 속성
} = {
  name: "jungyu",
  age: 20,
};
```
readonly
- 읽기전용 속성으로, 값을 초기화 한 이후에는 변경할 수 없음 
옵셔널 속성
- 키값에 ?를 붙이면 이 속성은 선택적인 속성이 되며 있어도 그만 없어도 그만인 속성이 됨