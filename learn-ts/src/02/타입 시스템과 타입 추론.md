# 타입 시스템과 타입 추론

## 코드 블럭 `{ }`

- TS는 정적 타입 언어, `tsconfig.json` 의 설정에 포함된 모든 파일을 타입 검사 대상으로 삼음
  ```jsx
  // 1.ts
  let name: "Alice";
  ```
  ```jsx
  // 2.ts
  let name: "Alice";
  ```
  → 서로 다른 파일에서 동일한 식별자를 사용 시, 충돌이 발생하고 오류가 남
- `{ }` : 코드 블럭 내부에서 선언된 변수는 블럭 스코프를 가지며, 외부에 영향을 주지 않음
  → let, const 는 블럭 스코프를 따르기 때문에, 같은 이름의 변수를 다른 블럭에서 선언해도 충돌 발생 x
  → 코드 블럭 활용 시, 각 파일 내부에서 독립적인 타입스크립트 코드 작성이 가능함 ( 전역 스코프 오염 없이 안정적인 코드 구성 가능 )
- 블럭 스코프 : let, const는 블럭 스코프를 따름, 같은 이름의 변수를 블럭마다 독립적으로 선언 가능

## 타입 시스템

- 기본 타입 : string, number, boolean, null, undefined, any, unknown
- 심화적인 타입 : array, tuple, bigint, object

### 1. string

```tsx
let name: string = "Alice";
let greeting: string = `Hello,${name}`;
let multiLine: string = `This is
a multiline string`;
```

### 2. number

```tsx
let age: number = 10; // 10진수
let hex: number = 0xff; // 16진수
let binary: number = 0b1010; // 2진수let float: number = 3.14; // 실수
```

### 3. boolean

- `falsy` : false, 0, -0, '', null, undefined, NaN
- `truthy` : falsy를 제외한 모든 값

```tsx
let bool1: boolean = true;
let bool2: boolean = false;
let bool3: boolean = !0;
let bool4: boolean = 10 > 20;
```

### 4. null

```tsx
let nothing: null = null;
```

### 5. undefined

```tsx
let notDefined: undefined = undefined;
```

### 6. any

- 타입 검사를 하지 않겠다.
- 타입 검사를 무력화 하는 타입이기 때문에 남용을 피해야 함.

```tsx
let anything: any = 10;
anything = 20;
anything = "A";
anything = true;
anything = null;
anything = undefined;
anything.toFixed(2); // ❌ 오류 발생
```

→ `toFixed`는 숫자형에만 사용 가능, 현재 타입이 `undefined`임에도 타입 스크립트는 이상한걸 찾지 못함, 실행을 하면 그제서야 오류 발생

### 7. unknown

- (any 순한맛, 안전한 any)
- 타입 검사를 하지 않는다.
- 단, 그 값을 사용하려고 할 때는 타입을 검증해야 함. (모든 값을 넣을 수는 있지만, 문법적인 검사는 함)
- `any` vs `unknown`
  - 개발 과정에서는 필요에 의해 사용하더라도, 최종적으로는 걷어내야하는 타입 !!
  - `unknown`이 할당할 때는 모든 값을 할당할 수 있는 자유도는 있지만, `unknown`에 할당된 변수의 값을 사용할 때에는 검증을 거쳐야하기 때문에 `any`보다는 `unknown`이 안전하고, 권장되는 타입임

```tsx
let input: unknown = "Hello";
input = 10;
input = true;
input = undefined;
input = 3.14;
// console.log(input.toFixed(2)) -> ❌ 타입 에러 발생

// number라는 확신을 주면 사용 가능함
if (typeof input === "number") console.log(input.toFixed(0));
```

- `number`라는 확신을 주고 `unknown`을 쓸 바에는 그냥 `number`를 쓰는게 낫지 않나…?
  - 내가 컨트롤하는 코드고, 입력값이 항상 `number`라는게 보장될 때는 `number` 사용
  - 외부에서 오는 값(API, 유저 입력 등)과 같이 어떤 타입이 들어올지 모를 때, `any`처럼 무조건 통과되게 하지 않고, 안전장치가 필요할 떄 사용

### 8. array

```tsx
let arr: [] = []; // ‼️ 배열은 실제로 이 안에 무슨 값이 들어가느냐가 중요함
let numArr: number[] = [10, 20];
let strArr: string[] = ["a", "b", "c"];
let boolArr: boolean[] = [true, false];
let undefinedArr: undefined[] = [undefined, undefined];
let nullArr: null[] = [null, null];

// 중첩 배열
let matrix: number[][] = [
  // number[][]: number 배열이 들어간 배열
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
];
```

- 제네릭 타입 사용 ( Array<> )
  ```tsx
  let numArr: Array<number> = [10, 20];
  let strArr: Array<string> = ["a", "b", "c"];
  let matrix: Arrary<Array<number>> = [
    // number[][]: number 배열이 들어간 배열
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9],
  ];
  ```

### 9. tuple

- 특정 형태를 갖는 배열을 의미 → 고정된 인덱스에 고정된 형태의 값만 올 수 있음

```tsx
let mixArr1: [number, string] = [10, "a"];
let mixArr2: [number, number[]] = [10, [20, 30]];
let mixArr3: [number, [], {}] = [10, [], {}];

let mixTuple: [number, string, {}][] = [
  [1, "hello", {key: "value"}],
  [2, "hi", {key: "example"}],
];
```

### 10. bigint

```tsx
console.log(Number.MAX_SAFE_INTEGER); // 9007199254740991
const bigNumber: bigint = 9007199254740997n;
console.log(bigNumber);

// bigint는 bigint끼리만 연산 가능
console.log(100n + 200n);
// 100n, 200n 너무 작지 않나? : 숫자의 크기와 관계없이 'n'이 붙으면 bigint 타입인 것
// console.log(100n + 200); -> 불가능
```

### 11. object

```tsx
// 객체의 속성 모양과 똑같이 타입을 지정함
const user: {
  name: string;
  age: number;
} = {
  name: "sucoding",
  age: 20,
};
```

- 모든 속성의 값 허용 가능한 자료형
- 빈 객체 지정
  - **object 사용**
    - 코드 예시
      ```tsx
      // 빈 객체 지정 1
      let obj: object = {}; // -> 배열, 함수 할당 가능

      // 할당 불가능
      obj = null;
      obj = undefined;
      obj = 10;
      obj = "A";

      // 할당 가능
      obj = [];
      obj = function () {};
      ```
    - 래퍼객체 : 원시타입 ( primitive type ) → 최상위 object로부터 떨어져나온 데이터 값이라 할당 불가능함
    - 배열, 함수는 object 객체를 직접적으로 상속받기 때문에 할당 가능
  - **{} 사용**
    - 코드 예시
      ```tsx
      // 빈 객체 지정 2
      let obj: {} = {}; // null과 undefined를 제외한 모든 값을 허용하겠다가 됨

      // 할당 불가능
      obj = null;
      obj = undefined;

      // 할당 가능
      obj = 10;
      obj = "A";
      obj = [];
      obj = function () {};
      ```
  - **유틸리티 타입 ( Record<string, never> )**
    - 타입스크립트에서 특정 타입을 지정하기 위해 미리 만들어놓은 함수
    - 즉, Record라는 이미 만들어진 함수의 기능을 통해 새로운 타입의 유형을 만들어낸 것
    - 코드 예시
      ```tsx
      // 빈 객체 지정 3 (유틸리티 타입)
      let obj: Record<string, never> = {};

      // 할당 가능
      obj = {};

      // ⬇️ 전부 할당 불가능해짐 !
      obj = null;
      obj = undefined;
      obj = 10;
      obj = "A";
      obj = [];
      obj = function () {};
      ```
    - `Record<string, never>` : 객체의 키 값은 문자열이고, 객체의 속성 값은 절대 올 수 없다. = 빈 객체

## 타입 추론 ( **Type Inference** )

- 변수에 할당되는 값을 보고 타입스크립트 컴파일러가 **할당될 값의 타입을 추론**해주는 현상

```tsx
let num = 10;
let name = "Hello";
let bool = true;
let unde = undefined; // any 타입으로 추론됨
let nul = null;
let symbol = Symbol("a");
let numArr = [1, 2, 3];
let obj = {name: "sucoding", age: 20};
let big = 100n;
// ↑↑↑ .ts 파일에서 타입 지정 안했는데 왜 오류 안생김??? -> "타입 추론" 때문

bool = false;
// -> 재할당 가능, 왜? TS가 bool이라는 변수를 boolean이라는 타입으로 추론한 상태라

// 할당 불가능
bool = "A"; // ❌
bool = 10; // ❌
```

→ 왜 `undefined`, `null`은 any 타입으로 추론 되나?

: `undefined`, `null`로 할당된 값은 이후에라도 다른 값으로 할당될 수 있다고 TS가 생각하기 때문
