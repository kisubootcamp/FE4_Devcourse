{
  // 이렇게 하면 객체의 속성을 동적으로 추가나 삭제할 수 없음.
  // 옵셔널 속성으로 지정하면 가능함.
  const obj: {
    name: string;
    // age: number;
    age?: number;
  } = {
    name: "yubin",
    age: 26,
  };

  delete obj.age;

  // 범용적인 타입 지정 방법
  // 인덱스 시그니처
  // -> 범용적으로 객체의 타입을 지정할 때 사용
  // 장점 : 한 번 타입을 정해놓으면 얼마든지 객체에 추가나 삭제가 가능함 !! (타입은 맞아야 함)
  // BUT, 결국 특정 변수에 담겨져있는 객체의 속성이 불분명한 것임. 명확하지 않음. 무슨 키가 무슨 값인지는 모름.
  // -> 유니온 타입의 단점과 같은 맥락.
  // -> 값을 사용할 때 유니온 타입처럼 타입 가드를 사용해야 함.
  // 타입으로 수동으로 지정하는 것과 인덱스 시그니처는 각각의 장단점이 있음.

  // (1)일반 속성 지정하는 방법과 (2)인덱스 시그니처를 MIX한 방법
  // 객체에 포함된 속성이 확실한 건 (1), 나머지는 (2)를 사용하는 것 !!!
  // 속성명은 명확한데 그 속성이 있을지는 불명확하면 옵셔널 프로퍼티 사용. 속성명도 명확하지 않으면 인덱스 시그니처 사용.
  const obj2: {
    [key: string]: string | number;
  } = {
    name: "yubin",
    age: 26,
  };

  obj2.gender = "female";
  delete obj2.name;

  // 객체라서 가능한 방법
  // 1. 옵셔널 프로퍼티 -> ?
  // 2. readonly 프로퍼티
  // 3. 인덱스 시그니처

  // 타입 별칭, 인터페이스여도 당연히 인덱스 시그니처 사용 가능.
  // 타입 별칭과 인터페이스이기 때문에 인덱스 시그니처를 사용할 수 있는 게 아님 !!!
  // 원래 객체 타입은 위의 3가지 방법 다 사용 가능하기 때문에 타입 별칭과 인터페이스에서도 사용 가능한 것임.
  type ObjType = {
    [key: string]: string | number;
  };
  interface ObjInterface {
    [key: string]: string | number;
  }
}
