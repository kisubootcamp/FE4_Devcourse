### 타입 별칭의 장점

- 가독성이 좋아지고 유지보수성이 증가한다.
- 타입을 재사용할 수 있다.
- 리터럴 타입도 타입 별칭으로 지정 가능하다.
---
### 키 선택 타입 별칭
>keyof 키워드를 사용하면 객체 타입의 키들을 유니언 타입으로 얻을 수 있다.

```ts
type Person = {
  name: string;
  age: number;
  gender: string;
};

type PersonOfKeys = keyof Person; // "name" | "age" | "gender"
const key: PersonOfKeys = "gender";
```
---

### 객체 선택 타입 별칭
> typeof 연산자를 사용해 기존 객체로부터 타입을 추론하여 타입 별칭으로 사용할 수 있다.
```ts
type User = typeof user;

const user = {
  name: "sucoding",
  age: 20,
};

const user2: User = {
  name: "a",
  age: 30,
};
```
---
### 재귀 타입 별칭
> 타입 정의 안에서 자기 자신을 다시 사용하는 재귀 형태의 타입 지정도 가능하다.

```ts
type Category = {
  name: string;
  subCategory?: Category[];
};

const category: Category = {
  name: "Electronics",
  subCategory: [
    {
      name: "Phones",
    },
    {
      name: "Laptops",
      subCategory: [
        {
          name: "Gaming Laptops",
        },
      ],
    },
  ],
};
```
### 인터페이스 (interface)
> 객체의 타입을 정의할 때 사용한다.
- 중복 선언이 가능하며 병합된다. (선언 병합)
- 마우스를 올려도 속성 타입을 보여주지 않는다.
- extends를 통해 상속이 가능하다.

``주의할 점은 같은 속성을 병합할 때 타입이 달라지면 안 된다.``

### 타입 별칭과 인터페이스 사용 기준
-타입 별칭으로 인터페이스에서 가능한 대부분을 대체할 수 있다.
-실무에서는 객체 타입 정의에는 인터페이스를 사용하고, 그 외에는 타입 별칭을 사용하는 경향이 있다.
-단순한 객체 구조 정의에는 인터페이스 사용
-유니언, 튜플, 함수 타입, 기본 타입 등은 타입 별칭 사용
-API 응답 타입에는 타입 별칭을 주로 사용한다.

---

### 범용적인 타입 지정 방법
- **옵셔널 프로퍼티**: 물음표(?)를 사용하여 해당 프로퍼티의 존재 여부를 선택적으로 만든다.
- **readonly** 프로퍼티: readonly 키워드를 사용하여 값을 수정할 수 없도록 한다.
- **인덱스 시그니처**: 객체의 키와 값을 정의할 수 있다. 인터페이스와 타입 별칭에서 모두 사용 가능하다.

### 헝가리안 표기법
> 변수명에 타입 정보를 포함하는 방식. <br/>
예) nNumber, strName 등

``요즘은 지양하는 추세이고 의미 있는 이름을 짓는 것이 좋다고 권장됨.``

### 구별된 유니온 타입
> 타입마다 식별 가능한 고유한 값을 갖도록 하여 안전하게 구분할 수 있는 유니온 타입 구성 방법

### enum과 const enum의 차이
- enum은 컴파일 시 JS 코드로 변환된다. 디버깅이 용이하다.
- const enum은 코드에서 직접 값으로 치환되어 사용되며, 번들 크기가 작아진다. 대신 디버깅이 어렵다.
- enum은 양방향 매핑이 가능하여, 값으로 키를 찾을 수도 있다.

### 타입 단언
타입스크립트가 타입을 추론하지 못하거나, 개발자가 더 정확히 알고 있는 경우 타입을 단언할 수 있다.

### null 아님 보장 연산자 (!)
값이 null이 아님을 확신하는 경우 느낌표(!)를 사용해 컴파일러에게 알려줄 수 있다. <br/>>
예) someElement!.textContent

