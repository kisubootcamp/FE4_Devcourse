// 상태 -> 시간이 지남에 따라 변할 수 있는 데이터를 의미
// useState, useReducer -> 리액트 훅 (v16.8)
// 상태를 정의해야만, 정의된 상태를 감지할 수 있음
// 강사님이 부르시는 "상태" : 상태 변수 (리액트 변수)

import {useState} from "react";

// const [state, setState] = useState<Type>(초깃값)
// state -> 상태 변수  (아무렇게나 지어도 됨 , set)
// setState -> 상태 업데이트 함수  (set*** 형태로 식별자를 짓는 관례가 있음 , setCount)
export default function Count() {
  // 리-렌더링 (re-rendering)
  // 상태변수의 값이 변경되었을 때, React는 그 컴포넌트를 다시 렌더링 한다.
  // 초깃값과 변경되는 값의 데이터 타입이 일치할 때, 이때는 제네릭을 생략할 수 있다. (강사님은 생략하는 걸 선호한다고 하심)
  // 초깃값과 변경되는 값의 데이터 타입이 다를 때, 이때는 제네릭을 생략할 수 없다.
  const [count, setCount] = useState<number>(0); // [현재 상태 값, 상태 값을 업데이트할 수 있는 함수]
  const clickHandler = () => {
    // count += 1; -> Error 재할당 불가능, 그렇다고 let으로 바꾸면 console 숫자는 바껴도 화면의 숫자가 안바뀜
    // 상태 업데이트 함수 사용 ! ⭐️⭐️⭐️
    // 1️⃣ 상태업데이트함수(값) -> 상태 업데이트 함수에 값을 매개변수로 전달 -> 상태 변수는 "값"으로 업데이트 됨
    // ⭐️ 현재 상태 값을 참조하지 않아도 된다면, 값을 넘기는 형태를 사용
    // setCount(2000);
    // 2️⃣ 상태업데이트함수(콜백함수) -> 콜백함수의 반환값이 최신 상태 값이 됨
    // ⭐️현재 상태값을 참조해야하면, 콜백함수 넘기는 형태를 사용해야 함 !
    // setCount(() => 2000);

    // 무슨 차이지??? 왜 업데이트 방법이 두가지지??
    // -> 콜백함수를 매개변수로 전달 시, 항상 최신의 상태값이 콜백함수의 매개변수로 전달됨
    setCount((count) => count + 1);

    //setCount(count + 1); // 비동기 (상태의 값이 변경될 때까지 코드를 기다려주지 않음)
    console.log(count);
    // 여전히 화면에 렌더링 되는 숫자랑 콘솔의 숫자가 1씩 차이남 그럼 렌더링 되는 값이랑 콘솔의 값을 맞춰주려면 어떻게 해야함 ???
  };
  return (
    <>
      {/* 
        그냥 {count} 입력 시, 증가되는 count가 화면에 반영되지 않음
        왜 ?
          -> React는 let, const로 선언된 변수의 값이 변경되는 것을 인지하지 못함
          그래서 실제로 count 값은 변하고 있지만 렌더링 되고있는 화면에는 아무런 변화도 없는 것
      */}
      <h1>Count: {count}</h1>
      <button onClick={clickHandler}>증가</button>
    </>
  );
}
